(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{456:function(_,v,t){"use strict";t.r(v);var a=t(15),s=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p",[_._v("本文为《现代操作系统：原理与实现》（陈海波著）的阅读笔记。")]),_._v(" "),t("h2",{attrs:{id:"_1-进程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-进程"}},[_._v("#")]),_._v(" 1. 进程")]),_._v(" "),t("h3",{attrs:{id:"_1-1-fock-进程创建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-fock-进程创建"}},[_._v("#")]),_._v(" 1.1 fock：进程创建")]),_._v(" "),t("p",[_._v("在linux中，fock会复制一个进程的全部信息，成为一个全新的进程，并返回其PID（两次）。这个过程，这事linux创建进程的唯一方式。其中写时拷贝会优化fock的过程，使其效率更高。")]),_._v(" "),t("p",[_._v("第一个进程怎么创建：")]),_._v(" "),t("h3",{attrs:{id:"_1-2-execve-进程的执行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-execve-进程的执行"}},[_._v("#")]),_._v(" 1.2 execve：进程的执行")]),_._v(" "),t("h3",{attrs:{id:"_1-3-进程树、进程间监控与僵尸进程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-进程树、进程间监控与僵尸进程"}},[_._v("#")]),_._v(" 1.3 进程树、进程间监控与僵尸进程")]),_._v(" "),t("p",[t("strong",[_._v("linux进程间监控用的是waitpid")]),_._v("，由父进程调用waitpid对子进程进行监控。wait不仅有监控的作用，还有释放资源的作用。")]),_._v(" "),t("p",[_._v("如果父进程没有调用waitpid，子进程就结束了，此时资源没有完全释放，这个进程就变成了"),t("strong",[_._v("僵尸进程")]),_._v("。")]),_._v(" "),t("h3",{attrs:{id:"_1-4-概念-进程组-process-与会话-session"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-概念-进程组-process-与会话-session"}},[_._v("#")]),_._v(" 1.4 概念：进程组(process)与会话(session)")]),_._v(" "),t("p",[_._v("概念关系：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("进程组是进程的集合")])]),_._v(" "),t("li",[t("p",[_._v("会话是进程组的集合")])])]),_._v(" "),t("p",[_._v("进程组存在的意义：主要是体现在信号的处理上，信号是由软件发出的类似中断的操作。当对一个进程组发出信号时，信号会发送给进程组的每个进程。")]),_._v(" "),t("p",[_._v("会话可以根据进程组的执行状态将其分为“前台进程组”和“后台进程组”。")]),_._v(" "),t("p",[_._v("控制终端进程是会话与外界进行交互的“窗口“，负责接收用户发来的输入。")]),_._v(" "),t("p",[_._v("在一个进程中会有三个标识：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("pid：进程号")])]),_._v(" "),t("li",[t("p",[_._v("gid：进程组号")])]),_._v(" "),t("li",[t("p",[_._v("sid：会话号")])])]),_._v(" "),t("h2",{attrs:{id:"_2-线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-线程"}},[_._v("#")]),_._v(" 2. 线程")]),_._v(" "),t("p",[_._v("线程出现的原因：")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("创建进程的开销大，需要创建独立的地址空间。（线程创建速度比进程快10-100倍）")])]),_._v(" "),t("li",[t("p",[_._v("进程间进行数据共享麻烦而且开销大")])])]),_._v(" "),t("p",[_._v("另外需要注意："),t("strong",[_._v("线程是操作系统资源调度的基本单位")]),_._v("。通常使用超线程技术的CPU可以一个核心同时处理两个线程，因此出现了4核8线程等CPU。")]),_._v(" "),t("h3",{attrs:{id:"_2-1-多线程的地址空间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-多线程的地址空间"}},[_._v("#")]),_._v(" 2.1 多线程的地址空间")]),_._v(" "),t("p",[_._v("多线程在一个进程内，他们的地址空间有两个重要的特征：")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("分离的内核栈和用户栈。")])]),_._v(" "),t("li",[t("p",[_._v("共享的其他区域（代码库，用户堆，数据，代码等）")])])]),_._v(" "),t("h3",{attrs:{id:"_2-2-用户态线程与内核态线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-用户态线程与内核态线程"}},[_._v("#")]),_._v(" 2.2 用户态线程与内核态线程")]),_._v(" "),t("p",[_._v("根据由用户态应用还是内核创建，将线程分为用户态线程和内核态线程。")]),_._v(" "),t("p",[_._v("区别：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("用户态线程是自己创建的，内核不可见，不接受操作系统调度器直接管理。")])]),_._v(" "),t("li",[t("p",[_._v("用户态线程比内核态线程更加轻量级，创建开销小。")])]),_._v(" "),t("li",[t("p",[_._v("用户态线程的功能受限。")])])]),_._v(" "),t("p",[_._v("但是有时候需要用户态线程与内核态线程"),t("strong",[_._v("相互协作")]),_._v("，所以操作系统会建立两者之间的关系，有三种：")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("多对一模型")])]),_._v(" "),t("li",[t("p",[_._v("一对一模型（Linux和Windows所采用）")])]),_._v(" "),t("li",[t("p",[_._v("多对多模型（macOS和iOS的调度器GCD采用）")])])]),_._v(" "),t("h3",{attrs:{id:"_2-3-线程控制块与线程本地存储"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-线程控制块与线程本地存储"}},[_._v("#")]),_._v(" 2.3 线程控制块与线程本地存储")]),_._v(" "),t("p",[_._v("线程控制块（Thread Control Block, TCB）主要用于保存线程自身的相关信息。")]),_._v(" "),t("p",[_._v("线程本地存储(Thread Local Storage, TLS)可以实现"),t("strong",[_._v("线程内的全局变量")]),_._v("。")]),_._v(" "),t("h3",{attrs:{id:"_2-4-线程的基本接口-posix线程库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-线程的基本接口-posix线程库"}},[_._v("#")]),_._v(" 2.4 线程的基本接口：POSIX线程库")]),_._v(" "),t("p",[_._v("这部分参看书籍P95 5.3.4")]),_._v(" "),t("h3",{attrs:{id:"_2-5-线程的实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-线程的实现"}},[_._v("#")]),_._v(" 2.5 线程的实现")]),_._v(" "),t("p",[_._v("这部分参照："),t("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/awesome-os-guide/e10o0h/",target:"_blank",rel:"noopener noreferrer"}},[_._v("Leetcode 硬核操作系统指南 线程实现"),t("OutboundLink")],1)]),_._v(" "),t("p",[_._v("主要分为两种，在用户空间实现和在内核中实现")]),_._v(" "),t("h2",{attrs:{id:"_3-线程的调度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-线程的调度"}},[_._v("#")]),_._v(" 3. 线程的调度")]),_._v(" "),t("h3",{attrs:{id:"_3-1-调度的目标"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-调度的目标"}},[_._v("#")]),_._v(" 3.1 调度的目标")]),_._v(" "),t("p",[_._v("由于应用种类繁多，调度的目标也各不相同。根据调度任务的不同，总结如下：")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/molinchn/BlogImage/raw/master/img/1612665024-CbaTgb-os2-33.png",alt:"os2-33.png"}})]),_._v(" "),t("h3",{attrs:{id:"_3-2-调度任务总览"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-调度任务总览"}},[_._v("#")]),_._v(" 3.2 调度任务总览")]),_._v(" "),t("p",[_._v("此部分见P116 图6-4，这里有图的过程以及各部分的解释。")]),_._v(" "),t("h3",{attrs:{id:"_3-3-调度方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-调度方法"}},[_._v("#")]),_._v(" 3.3 调度方法")]),_._v(" "),t("p",[_._v("LeetBook中的分类是按照不同应用来分的，大体如下:")]),_._v(" "),t("p",[t("strong",[_._v("批处理任务调度：")])]),_._v(" "),t("ol",[t("li",[t("p",[_._v("FCFS，先到先服务")])]),_._v(" "),t("li",[t("p",[_._v("最短作业优先（最短任务优先, Shortest Job First, "),t("strong",[_._v("SJF")]),_._v("）")])]),_._v(" "),t("li",[t("p",[_._v("最短剩余时间优先（2的抢占式版本，也叫最短完成时间任务优先, Shortest Time-to-Complete First, "),t("strong",[_._v("STCF")]),_._v("）")])])]),_._v(" "),t("p",[t("strong",[_._v("交互式系统的调度：")])]),_._v(" "),t("ol",[t("li",[_._v("轮询调度（时间片轮转, Round Robin, "),t("strong",[_._v("RR")]),_._v("）")]),_._v(" "),t("li",[_._v("优先级调度\n"),t("ol",[t("li",[_._v("多级队列("),t("strong",[_._v("MLQ")]),_._v(")")]),_._v(" "),t("li",[_._v("多级反馈队列（"),t("strong",[_._v("MLFQ")]),_._v("，"),t("strong",[_._v("早期的Linux，Windows，macOS")]),_._v("）")])])]),_._v(" "),t("li",[_._v("公平共享调度策略\n"),t("ol",[t("li",[_._v("彩票调度")]),_._v(" "),t("li",[_._v("步幅调度")])])]),_._v(" "),t("li",[_._v("最短进程优先")]),_._v(" "),t("li",[_._v("保证调度")])]),_._v(" "),t("p",[_._v("实时系统中的调度：")]),_._v(" "),t("p",[_._v("这里只介绍了一下，没有具体方案。")]),_._v(" "),t("p",[_._v("在书中还介绍了多核调度策略，主要内容有：")]),_._v(" "),t("ul",[t("li",[_._v("负载分担")]),_._v(" "),t("li",[_._v("协同调度")]),_._v(" "),t("li",[_._v("两级调度")]),_._v(" "),t("li",[_._v("负载追踪与负载均衡")]),_._v(" "),t("li",[_._v("能耗感知调度")])]),_._v(" "),t("h2",{attrs:{id:"_4-进程间通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-进程间通信"}},[_._v("#")]),_._v(" 4. 进程间通信")]),_._v(" "),t("h3",{attrs:{id:"_4-1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1"}},[_._v("#")]),_._v(" 4.1")])])}),[],!1,null,null,null);v.default=s.exports}}]);