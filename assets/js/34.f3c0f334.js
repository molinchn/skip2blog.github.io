(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{458:function(_,v,t){"use strict";t.r(v);var a=t(15),s=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"进程间通信、同步原语"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程间通信、同步原语"}},[_._v("#")]),_._v(" 进程间通信、同步原语")]),_._v(" "),t("p",[_._v("本文为《现代操作系统：原理与实现》（陈海波著）的阅读笔记，第七章、第八章的内容概要与笔记。")]),_._v(" "),t("h2",{attrs:{id:"_1-进程间通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-进程间通信"}},[_._v("#")]),_._v(" 1. 进程间通信")]),_._v(" "),t("p",[_._v("进程间通信（Inter-Process Communication, IPC）是操作系统最重要的内容之一。")]),_._v(" "),t("h3",{attrs:{id:"_1-1-基础概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-基础概念"}},[_._v("#")]),_._v(" 1.1 基础概念")]),_._v(" "),t("p",[_._v("IPC常被用于服务调用，因此参与IPC的两方又被称为"),t("strong",[_._v("调用者")]),_._v("和被"),t("strong",[_._v("调用者")]),_._v("，或者"),t("strong",[_._v("客户端")]),_._v("和"),t("strong",[_._v("服务端")])]),_._v(" "),t("p",[_._v("消息传递的接口：")]),_._v(" "),t("ul",[t("li",[_._v("Send")]),_._v(" "),t("li",[_._v("Recv")]),_._v(" "),t("li",[_._v("RPC(req_message, resp_message) 远程过程调用")]),_._v(" "),t("li",[_._v("Reply")])]),_._v(" "),t("p",[_._v("两种消息传递方式：")]),_._v(" "),t("ul",[t("li",[_._v("共享内存")]),_._v(" "),t("li",[_._v("操作系统辅助")])]),_._v(" "),t("p",[_._v("单向与双向，同步与异步")]),_._v(" "),t("p",[_._v("同步IPC往往是双向IPC，即发送者需要等待返回结果（但并不绝对）。")]),_._v(" "),t("h3",{attrs:{id:"_1-2-宏内核进程间通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-宏内核进程间通信"}},[_._v("#")]),_._v(" 1.2 宏内核进程间通信")]),_._v(" "),t("p",[_._v("这部分讲宏内核，下部分讲微内核。但实际上主要的通信方式就是宏内核这几种。后面微内核主要倾向于性能的讲解。因此微内核暂时忽略，主要学习宏内核的部分")]),_._v(" "),t("p",[_._v("一共有六种重要的通信方式：")]),_._v(" "),t("ul",[t("li",[_._v("管道")]),_._v(" "),t("li",[_._v("消息队列")]),_._v(" "),t("li",[_._v("信号量")]),_._v(" "),t("li",[_._v("共享内存")]),_._v(" "),t("li",[_._v("信号")]),_._v(" "),t("li",[_._v("套接字")])]),_._v(" "),t("h4",{attrs:{id:"管道"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#管道"}},[_._v("#")]),_._v(" 管道")]),_._v(" "),t("p",[_._v("单向IPC，只能两个进程参与")]),_._v(" "),t("h4",{attrs:{id:"消息队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[_._v("#")]),_._v(" 消息队列")]),_._v(" "),t("p",[_._v("唯一一个以消息作为抽象的通信方式")]),_._v(" "),t("p",[_._v("可单向可双向。参与数可以为多进程。")]),_._v(" "),t("h4",{attrs:{id:"信号量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#信号量"}},[_._v("#")]),_._v(" 信号量")]),_._v(" "),t("p",[_._v("就是一个共享计数器。")]),_._v(" "),t("p",[_._v("可单向可双向。参与数可以为多进程。")]),_._v(" "),t("p",[_._v("PV操作：P为减1，V为加1。信号量取值为0-1，小于0和大于1都会触发特定操作。通常来说，用作同步时，小于0会阻塞进程。")]),_._v(" "),t("h4",{attrs:{id:"共享内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#共享内存"}},[_._v("#")]),_._v(" 共享内存")]),_._v(" "),t("p",[_._v("顾名思义，就是维护共享的物理内存。")]),_._v(" "),t("p",[_._v("可单向可双向。参与数可以为多进程。")]),_._v(" "),t("h4",{attrs:{id:"信号"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#信号"}},[_._v("#")]),_._v(" 信号")]),_._v(" "),t("p",[_._v("单向IPC，但是可以多进程。")]),_._v(" "),t("p",[_._v("底层是个队列。")]),_._v(" "),t("p",[_._v("只发送一个编号（信号编号），会触发特定的处理函数。")]),_._v(" "),t("p",[_._v("有点类似硬件的中断，但是它是由软件发出的。")]),_._v(" "),t("h4",{attrs:{id:"套接字"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#套接字"}},[_._v("#")]),_._v(" 套接字")]),_._v(" "),t("p",[_._v("就是网络编程中的套接字，不过用在了本地。")]),_._v(" "),t("p",[_._v("只能用于两个进程，不过方向可以单可以双。")]),_._v(" "),t("h3",{attrs:{id:"_1-3-微内核进程间通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-微内核进程间通信"}},[_._v("#")]),_._v(" 1.3 微内核进程间通信")]),_._v(" "),t("h2",{attrs:{id:"_2-同步原语"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-同步原语"}},[_._v("#")]),_._v(" 2. 同步原语")]),_._v(" "),t("h3",{attrs:{id:"_2-1-互斥锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-互斥锁"}},[_._v("#")]),_._v(" 2.1 互斥锁")]),_._v(" "),t("p",[_._v("有一些名词需要注意一下")]),_._v(" "),t("p",[t("strong",[_._v("竞争冒险")]),_._v("：指程序的正确性依赖于执行的顺序这一"),t("strong",[_._v("现象")]),_._v("。")]),_._v(" "),t("p",[t("strong",[_._v("互斥访问")]),_._v("：任意时刻，只允许一个线程的"),t("strong",[_._v("访问方式")]),_._v("。")]),_._v(" "),t("p",[t("strong",[_._v("临界区")]),_._v("：保证互斥访问共享资源的"),t("strong",[_._v("代码区")]),_._v("。")]),_._v(" "),t("p",[t("strong",[_._v("临界区问题")]),_._v("：如何设计协议保证互斥访问的"),t("strong",[_._v("问题")]),_._v("。")]),_._v(" "),t("p",[_._v("要解决临界区问题需要做到三点：")]),_._v(" "),t("ol",[t("li",[_._v("互斥访问")]),_._v(" "),t("li",[_._v("有限等待")]),_._v(" "),t("li",[_._v("空闲让进")])]),_._v(" "),t("p",[_._v("解决临界区问题有三个大方向：")]),_._v(" "),t("ul",[t("li",[_._v("利用硬件：关闭中断")]),_._v(" "),t("li",[_._v("利用软件：皮特森算法")]),_._v(" "),t("li",[_._v("软硬件结合："),t("strong",[_._v("互斥锁")])])]),_._v(" "),t("h4",{attrs:{id:"利用硬件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#利用硬件"}},[_._v("#")]),_._v(" 利用硬件")]),_._v(" "),t("p",[_._v("当一方访问时，关闭中断。")]),_._v(" "),t("p",[_._v("可以满足三点条件，但是多核环境不适用。")]),_._v(" "),t("h4",{attrs:{id:"利用软件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#利用软件"}},[_._v("#")]),_._v(" 利用软件")]),_._v(" "),t("p",[_._v("利用全局的flag[2]和true来保证两个程序互相控制。")]),_._v(" "),t("p",[_._v("当一个程序要运行时，只能让对方去运行，自己首先陷入等待。")]),_._v(" "),t("p",[_._v("注意CPU必须顺序执行。")]),_._v(" "),t("h4",{attrs:{id:"软硬件结合-互斥锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软硬件结合-互斥锁"}},[_._v("#")]),_._v(" 软硬件结合：互斥锁")]),_._v(" "),t("p",[_._v("终于引出了小结的标题。")]),_._v(" "),t("p",[_._v("互斥锁是指利用硬件保证的原子操作，配合软件的抽象实现的"),t("strong",[_._v("一种解决临界区问题的方式")]),_._v("。")]),_._v(" "),t("p",[_._v("原子操作有两种：")]),_._v(" "),t("ul",[t("li",[_._v("CAS: Compare And Swap")]),_._v(" "),t("li",[_._v("FAA: Fatch And Add")])]),_._v(" "),t("p",[_._v("这些原子操作是硬件保证的，它们中间不能被打断，一旦开始必会被执行完。")]),_._v(" "),t("p",[_._v("由于有两种原子操作，因此抽象出两种互斥锁：")]),_._v(" "),t("ul",[t("li",[_._v("利用CAS操作，抽象出了"),t("strong",[_._v("自旋锁")])]),_._v(" "),t("li",[_._v("利用FAA操作，抽象出了"),t("strong",[_._v("排号自旋锁")])])]),_._v(" "),t("p",[_._v("本部分详见P216，简要摘录一些重点：")]),_._v(" "),t("ul",[t("li",[_._v("大部分64位CPU对于地址对其的64位单一写操作都是原子的。")]),_._v(" "),t("li",[_._v("自旋锁并不能保证有限等待，不具有公平性")]),_._v(" "),t("li",[_._v("比如Arm移动端处理器大小核的设计，由于小核频率低于大核，有可能永远无法获得锁。")]),_._v(" "),t("li",[_._v("排号自旋锁由于每个进程领一个号码，保证了执行顺序，进而实现了有点等待。")])]),_._v(" "),t("h3",{attrs:{id:"_2-2-条件变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-条件变量"}},[_._v("#")]),_._v(" 2.2 条件变量")]),_._v(" "),t("p",[_._v("条件变量解决的问题是 "),t("strong",[_._v("循环等待")]),_._v("的问题，使用条件变量可以挂起程序，避免其陷入“是否还有空位”这种问题上。")]),_._v(" "),t("p",[_._v("线程挂起时，需要保证当前已经获取了互斥锁。")]),_._v(" "),t("h3",{attrs:{id:"_2-3-信号量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-信号量"}},[_._v("#")]),_._v(" 2.3 信号量")]),_._v(" "),t("p",[_._v("就是前面进程间通信中的信号量。")]),_._v(" "),t("p",[_._v("由于其PV操作，又被称为PV原语。")]),_._v(" "),t("p",[_._v("PV操作的对应关系：")]),_._v(" "),t("ul",[t("li",[_._v("P - 减1 - wait")]),_._v(" "),t("li",[_._v("V - 加1 - signal")])]),_._v(" "),t("p",[_._v("信号量的作用是："),t("strong",[_._v("辅助控制多个线程访问有限数量的共享资源")]),_._v("。")]),_._v(" "),t("p",[_._v("具体思想是：把信号量的初值设置成资源数量，如果消耗，则调用wait；如果释放，则调用signal。")]),_._v(" "),t("h3",{attrs:{id:"_2-4-读写锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-读写锁"}},[_._v("#")]),_._v(" 2.4 读写锁")]),_._v(" "),t("p",[_._v("读写锁解决的问题是：读并不需要互斥访问。写与读，写与写之间才需要。")]),_._v(" "),t("p",[_._v("这部分详见P229")]),_._v(" "),t("h3",{attrs:{id:"_2-5-rcu-2-6-管程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-rcu-2-6-管程"}},[_._v("#")]),_._v(" 2.5 RCU，2.6 管程")]),_._v(" "),t("p",[_._v("略")]),_._v(" "),t("h3",{attrs:{id:"_2-7-同步带来的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-7-同步带来的问题"}},[_._v("#")]),_._v(" 2.7 同步带来的问题")]),_._v(" "),t("h4",{attrs:{id:"死锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[_._v("#")]),_._v(" 死锁")]),_._v(" "),t("p",[_._v("一组线程都在互相等待对方释放资源，并且手中都持有一定资源。")]),_._v(" "),t("p",[_._v("死锁的条件（产生原因）：")]),_._v(" "),t("ul",[t("li",[_._v("互斥访问")]),_._v(" "),t("li",[_._v("持有并等待")]),_._v(" "),t("li",[_._v("资源非抢占")]),_._v(" "),t("li",[_._v("循环等待")])]),_._v(" "),t("p",[_._v("检测死锁的方式：针对循环等待。")]),_._v(" "),t("p",[_._v("利用"),t("strong",[_._v("资源分配表")]),_._v("记录不同资源被占有的情况，加上"),t("strong",[_._v("线程等待表")]),_._v("等待资源的情况，寻找"),t("strong",[_._v("环")]),_._v("。")]),_._v(" "),t("p",[_._v("死锁预防（就是针对原因的四点）：")]),_._v(" "),t("ul",[t("li",[_._v("避免互斥访问")]),_._v(" "),t("li",[_._v("不允许持有并等待")]),_._v(" "),t("li",[_._v("允许资源被抢占")]),_._v(" "),t("li",[_._v("避免循环等待")])]),_._v(" "),t("p",[_._v("银行家算法")]),_._v(" "),t("p",[_._v("大概就是，每次有线程申请资源时，操作系统先预演一遍，判断会不会死锁，如果会就让其等待，下次再行分配。")]),_._v(" "),t("p",[_._v("具体看P243")]),_._v(" "),t("h4",{attrs:{id:"活锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#活锁"}},[_._v("#")]),_._v(" 活锁")]),_._v(" "),t("p",[_._v("当不允许持有资源等待时，可能会发生活锁。")]),_._v(" "),t("p",[_._v("具体情况是，两个进程互相申请对方所持有对的资源 - 失败 - 互相放弃自己的资源 - 再申请 - 成功 - 申请 - 失败 - 。。。。。")]),_._v(" "),t("p",[_._v("这样循环下去，虽然没有持有资源并等待，但是仍然无法正常进行任务。")]),_._v(" "),t("h4",{attrs:{id:"优先级反转"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优先级反转"}},[_._v("#")]),_._v(" 优先级反转")]),_._v(" "),t("p",[_._v("优先级反转的例子见P247，高优先级的T1因为等待低优先级的T3，被中等优先级的T2阻塞。")]),_._v(" "),t("p",[_._v("优先级反转可能会导致严重的问题，例如高优先级的任务因为被阻塞而超过其截止时间（deadline)")]),_._v(" "),t("p",[_._v("解决优先级的方法主要有三种：")]),_._v(" "),t("ol",[t("li",[_._v("**不可抢占临界区协议：**即临界区的线程不能被抢占，"),t("strong",[_._v("所带来的问题就是")]),_._v("一些没有竞争关系的高优先级线程也会被阻塞。")]),_._v(" "),t("li",[t("strong",[_._v("优先级继承协议")]),_._v("【现代操作系统常用】：当高优先级等待锁时，会使锁的持有者继承其优先级。")]),_._v(" "),t("li",[_._v("**优先级置顶协议：**将锁的持有者线程优先级置为其竞争者中最高的优先级。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);